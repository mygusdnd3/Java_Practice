# day12


****
함수의 오버로딩(Overloading : 함수의 중첩)
==> 원칙적으로 같은 클래스 내에서는 함수의 이름은 모두 달라랴 한다.
	같은 클래스 내에서 이름이 같은 함수가 존재하면 에러가 발생한다.
	
	따라서 이렇게 작성 하다보면 가독성에 문제가 발생한다.
	즉, 가독성이란??
	함수의 이름만 봐도 그 함수가 어떤 기능을 가지고 있는 함수인지 알아야 하는데..
	함수의 이름을 모두 다르게 만든다면..
	==> 가독성에 있어서 문제가 발생할 수 있다.
	
	이런 문제를 해결하기 위해서 도입된 문법이 있는데
	이 문법이 함수의 오버로딩(함수의 중첩)
	
	오버로딩이란??
	같은 클래스 내에서 같은 이름의 함수를 만들 수 있다.
	단, 조건은 반드시 지켜줘야한다.
	
	****
	0.	오버로딩 하려는 함수가 존재하야 한다.
	1. 함수의 이름이 같아야 한다.
	2. 매개변수의 갯수, 순서, 형태 중 하나이상이 달라야 한다.
		매개변수 리스트의 형태가 달라야 한다.
	3. 반환값과 상관이 전혀 없다.
	
	예	]
	
		void abc(){
		}
		float abc(){ --x
		}//반환값과는 상관없다
		void abc{int a){
		}매개변수 리스트의 형태가 다르다
		int abc(String a, int b){
		}매개변수 리스트의 형태가 다르다
		int abc(int a){ //에러
		}반환값과는 상관없다.
		void abc(int a, int b){
		}매개변수 리스트의 형태가 다르다
		void abc(int a, String b){------------0
		}매개변수 리스트의 형태가 다르다
		
	
	결론]
	
		함수를 호출할때 정확한 함수를 선택할 수 있도록 해야 한다.
		
			예]
				public class Test(){
					public Test(){
					abc(); -------1번 함수 호출
					abc(10); -------2번 함수 호출
					abc(1,3) --------3번 함수 호출
					}
					void abc(){		----1
					}
					
					void abc{int a){ ------2
					}매개변수 리스트의 형태가 다르다
					int abc(int a, int b){ ----------3
					}매개변수 리스트의 형태가 다르다
					
					
	참고 ]
	
		다른 사람이 만든 클래스(api등..)에도 오버로딩이 구현된 함수를 불러올수 있습니다.
		이들 함수를 사용하는 방법
		원하는 기능을 하는 함수가 요구하는 데이터를
		형태와 순서에 맞춰서 정확하게 입력해서 호출하면 된다.
		
			참고 ]
			
				형태가 맞지 않더라도 실행 되는 경우가 있는데...
				이런 경우는 자동 형변환이 되는 경우는  형태가 맞지 않더라도 실행된다.
				
				
				
				
------------------------------------------------------------------------------------------------


 '메소드' -- 클래스 내부에 작성 '함수' -- 클래스 밖에 작성(java에는 없음, javascript에는 존재)
 java에서는 구분의 의미가 없다.
생성자 함수(Constructor)

==>		클래스를 사용하기 위하여 new 시키는 순간 자동 실행 되는 함수.
				new 라는 명령이 인스턴스를 만드는 것, Heap에다가
	예]
	
		class Test{		
		..
		}
			Test t = new Test();  Test()가 생성자 함수.
			
		즉, 클래스를 new 시키는 개념은 오브젝트(객체화)로 만들어서
		실행을 한다는 개념이다.
		
		따라서, 이 때 실행한다는 것은 결국 오브젝트를 만드는 순간에 뭔가를 실행한다는 것이다.
		이것은 물건을 만들때 필요한 뭔가 조치를 한다는 개념이다.
		
		==>> 결론적으로 
			 생성자 함수는 물건을 실제로 만들기 위한 함수이다
			 
		클래스는 한가지 목적을 달성하기 위해서 만들어지는 프로그램의 '최소' 단위이다.
		<<<<자바는 클래스 단위로 프로그램을 작성한다.>>>
		이 안에는 그 목저을 달성하기위한 변수, 함수(멤버)로 구성된다.
		하지만 그 목적을 달성하기 위해서는 가장 기본적인 어떤 조치가 필요한 경우가 있다
		삼각형을 완성하기위해서는 부가적인 것들이 필요하듯..?
		
		예 ]
		
			String 
				문자열을 고나리하기 위한 목적으로 만들어진 클래스이다.
				==> 문자열을 기억하고 있어야 한다.
				
			FileOutputStream
				파일에 내용을 기록하기 위한 목적으로 만들어진 클래스이다.
				==> 파일을 사용할 수 있도록 파일을 열어(?)놔야 할 것이다.
				
			Socket
				네트워크를 구성하기 위한 목적으로 만들어진 클래스이다.
				==> 상대방과 접속은 이져야 한다.
				
				
		프로그램은 프로그램 답게 뭔가를 처리하기 위해서는 함수(기능)가 필요하고
		위의 경우를 보자면 각각의 클래스는 오브젝트(인스턴스 객체)로 만들어지는 순간
		그 클래스만의 최소한의 일을 할 필요가 있다.
		
		
생성자 함수를 만드는 방법.

	규칙 ] 
		
		1. 함수의 이름은 **반드시** 클래스 이름과 대소문자까지 동일해야 한다.
		2. 반환값은 **절대로** 가지면 안되고 void라고 적어도 안된다. 
		3. 매개변수는 가질 수 있다.
		
	예	]
	
		class Test{
			public Test(){ -----------기본 생성자 함수
			
			}
			public Test(String name){ -----생성자 함수 오버로딩
			
			}
			int Test(int no){ X -------- 생성자 함수는 반환값을 가지면 안된다.
			}
			test(float no) { x -------------생성자 함수는 클래스 이름과 대소문자까지 동일해야함
			}
			
		}	
		
	참고	]
	
		생성자 함수는 오버로딩이 가능하다.
		==> 생성자 함수는 여러개 만들 수 있다.
		
		왜??
		<==
			필요하면 그 클래스가 기본적으로 해야할 일이 
			조금씩 달라질 수 있으므로
			
			예 ]
			
				문자열 데이터가 준비가 되어있다면
					==> new String("abcd");
					
				만약 아직 문자열이 준비되어 있지 않고, 특정 순간 이후에 결정이 된다면
					==> String str = new String();
						..
						str = "abcd";
						
						
		여러개의 생성자 함수가 있다는 것은
		new 시킬때 필요한 생성자 함수를 선택 할 수 있어야 한다.
		==> new 시키는 문법을 보면 답이 나온다.
			new 시키는 문법은 바로 생성자 함수를 호출하는 문법이다.
			
			예 ] 
				
				class Test{
					Test(){}
					Test(int a){}
				}
				
				// 두 함수가 일반함수일 경우 
				
				t.Test();
				t.Test(5);
				로 호출한다.
				
				생성자는 일반함수 처럼 사용하는 것이 아니고
				new Test();
				==> Object 를 만드는 문법
				new Test(5);
				==> Object 를 만드는 문법, 정수를 입력하면서....
				
				new Test(}
** JVM은 기본생성자를 만들어준다
	이때 개발자가 따로 만들어주면
	 JVM은 기본생성자를 만들어 주지않는다.
	 *************************************
		결론 ]
			매개변수가 있는 생성자 함수를 호출하기 위해서는
			new 시킬때 매개변수ㅏ 필요한 데이터를 주면서 new 시키면 된다.
			<== 데이터가 미리 준비 되어있어야 한다.
		
		 참고 ] 
		  	기본 생성자(Default Constructor)
		  	==> 매개 변수가 하나도 없는 생서앚 함수를 지칭하는 용어.
		  		예 ] 
		  			Test(){} 	<--기본 생성자.
		  			
	***
	자바는 생성자 함수가 없어도 new 시킬 수 있다.
	하지만 이것은 생성자 함수를 이용하지 않는 것이 아니고
	JVM 이 기본 생성자를 내부적으로 만들어 준 후
	이 생성자를 이용하는 것이 된다.
	
	결론적으로 
	JAVA는 new 시킬때마다 반드시 생성자 함수를 이용하게 된다.
	
	***
	만약 개발자가 생성자 함수를 한개라도 작성하게 되면,
	JVM은 기본 생성자를 만들어 주지 않는다. ==> 
	매개 변수가 있는 형테로 생성자를 정의하면 기본생성자를 사용할 수 없게 된다.
	즉, 내부적으로 기본 생성자를 만드는 경우는
	오직 개발자가 생성자 함수를 한개도 만들지 않았을 경우에 한해서 
	JVM이 기본 생성자를 만들게 된다.
	
	따라서 
	생성자를 정의 하게 될 경우는 
	되도록이면 기본 생성자의 내용이 없더라도
	정의 해 두는 것이 좋다.
	
	
생성자 함수 이용 방법

	결론 ]
		생성자 함수는 그 클래스를 어떻게 new 시킬지 알려주는 함수
		==> 준비된 데이터에 따라서 new 시킬때 입력하는 데이터가 달라진다.
		
		즉, 생성자 함수가 요구하는 매개 변수가 무엇인지를 보면,
		그 클래스를 객체로 만들 수 있는 방법이 도출이 된다.
		
		
------------------------------------------------------------------------------------

참고 ]
	this()
	==> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
	
	현재 상성자를 실행하는 도중에 다른 생성자(오버로딩된 생성자)를
	강제로 호출하는 유일한 방법
	
	
	**
	규칙
		1. 반드시 생성자 함수 내부에서만사용 해야 한다.
			==> 일반 함수 내에서는 사용할 수 없다.
		2. 반드시 생성자 함수의 첫 문장으로 사용해야 한다.
			this() 이전에 다른 문장이 있으면 에러가 발생한다.
			
	왜 사용해야 하는가?
		==> 클래스는 한가지 목적을 가진 프로그램의 집합니다.
			물론 기본적인 작업이 조금씩은 달라질 수 있지만
			그 틀 자체는 변하지 않는다.
			
			예 ]
				Socket은 접속할 대상의 주소와 포트번호는 바뀌겠지만
				결론은 접속을 시도해야 할 것이다.
				String은 데이터의 형태가 달라지겠지만
				결론은 문자열을 만들어야 할 것이다.
				
			그러므로 생성자 함수가 하는 기능은 거의 비슷할 것이다.
			기능이 비슷하다는 의미는
			내부 코드의 내용도 비슷하다는 것이다.
			따라서 가은 코드 내용이 중복되어서 작성되어질 것이다.
			이 작업을 조금이라도 단순화 시켜주기 위해서
		***	생성자 끼리는 서로 필요하면 상대방을 이용 할 수 있게
			만들어 놓은문법이다. 
--------------------------------------------------------------------------------------

향상된 for 명령 (foreach반복문)
==> 이 명령은 오직 데이터가 배열이거나 컬렉션일 경우에만 사용할 수 있는 반복문
	이 명령은 JAVA버전 1.4 이후 추가된 명령이다.
	
	형식	]
		for(데이터타입 변수이름(1) : 배열 또는 컬렉션){
		
		}
		
	참고 ]
		변수 이름(1)은 배열 또는 컬렉션에 저장된 데이터와 타입이 일치해야 한다.
		
	의미 ]
		배열 또는 컬렉션이 가진 실제 데이터의 갯수 만큼 자동 반복하면서
		실제 데이터를 주어진 변수 (변수이름(1))에 한개씩 기억되면서 반복한다.
		
	예	]
		int [] no = {1,2,3,4,5};
		
		for(int n : no){
			//1꺼내서 n에다 넣고 실행해주고
			//순차적으로 2 꺼내서 n에다 넣고 실행해주고
			
			//n의 타입은 no 배열의 데이터가 int 이므로 int 타입으로 만들어야 한다.
			
			// 1. 첫번째 회차에는 인덱스 0에 들어있는 데이터 1을 꺼내서 변수 n에
			//		대입을 해주고 그후 반복문 블럭을 실행하고
			
			// 2. 두번째 회차에는 인덱스 1에 들어있는 데이터 2을 꺼내서 변수 n에
			//		대입을 해주고 그후 반복문 블럭을 실행하고
			
			...
			
			
		} 
		
-------------------------------------------------------------------------------------

가변인자

==> 우리가 함수를 만들때
	그 함수가 가지고 있는 매개변수와 동일한 갯수, 형태, 순서를 이용해서 함수를 호출해야한다.
	
	예 ]
	
		void adb(int a){}
		
		==> abd(10);
		
		void abc(int a, int b){}
		==> abc(10,5);
		
	그런데 만약 입력해야할 데이터의 갯수를 지정할 수 없으면??
	배열을 사용하면 되긴하지만..
	
	==> 바로 이런경우 사용할 수 있는 개념의 매개변수 "가변인자"(가변인수) 이다.
	==> 이것은 데이터의 갯수에 상관 없이 모든 데이터를 다 받을 수 있도록 하는것.
	
	형식 ]
		(함수)
		[접근지정자]	[속성]	반환값타입	함수이름(데이터타입...매개변수이름){
		
		{
		
		예 ]
		
			void abc(int ...num){
			
			}
			
			abc(1);
			abc(1,2);
			abc(i,2,3,4,5);
			
	주의 ]
		가변 인자의 변수는 자동 배열 변수가 된다.
		따라서 배열 변수처럼 사용해야 한다.
		
		예	]
			for(int no : num){
				System.out.println(no);
			}
			
	주의 ] 
		가변인자 앞에는 다른 매개변수를 선언해도 상관 없다.
		가변인자 뒤에는 다른 매개변수를 선언할 수 없다.
		
		void abc(String s, int...num){} ---------O
		void abc(int...num,String s){}----------X
		
		 	  
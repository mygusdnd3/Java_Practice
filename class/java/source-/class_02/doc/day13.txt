# day13


----------------------------------------------------------------------------------------------------------------------------------
생성자 함수
	==> 클래스를 사용하기 위해서는 new 시켜야 한다.
		==> new 시키는 방법
		
			new Test();
			new Test(5);
			new Test(("hong");
			다양하게 new 시킬 수 있다.
		단, 생성자 함수를 오버로딩 해놨다면..
	결론]
		내가 어떤 클래스(부품)을 사용하고 싶은데
		그러면 new 시켜야하고
		내가 선택한 클래스를 어떻게 new 시켜야 하는가? 를
		어떻게 알 수 있는가?
		<-- 생성자 함수를 보면 알 수 있다.



----------------------------------------------------------------------------------------------------------------------------------


this.
==> 교과서 적인 의미로는
	실행중인 객체의 주소를 기억하는 약속된 변수이다.
	
	이것은 JVM이 클래스를 처리하기 위해서 JVM이 사용하는 변수이다.
	즉, 개발자는 거의 이 변수를 사용하진 않는다.
	
	규칙,
	1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야 한다.
		멤버는 클래스 안에 만들어진 변수나 함수를 부르는 용어이다.
		
		따라서 new를 시킨 후 그 주소를 기억해 놓았다가.
		그 주소를 이용해서 사용하는 것
		
	2. 만약 주소가 없으면 JVM이 자동적으로 this를 붙여준다.
	
		예 ]
			class Test{
			
			
			int no;
			public Test(){
				[this.]getNo();
			}
			int getNo(){
				return no; // <=== this.no 자동으로.
			}
	
	3. 멤버 함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속했고
		함수는 this변수를 준비한 후 
		함수를 호출할 때 알려준 주소를 기억하게 된다.

참고 ]
	딱 한번 this를 개발자가 사용해야 하는 경우가 있다.
	
	가끔은 지역변수와 멤버 변수가 이름이 동일하게 만든 경우가 발생한다.
	이러면 그 함수는 변수를 가장 가까운 지역 변수를 우선사용하게 된다.
	따라서 멤버 변수에는 데이터가 기억되지 않을 수 있다.
	
	*
	이때 
	굳이 이 변수가 멤버 변수임을 꼭 밝히고 싶은 경우가 생기면 ..
	이때 강제로 this라고 써주면 된다.
	
	class Test{
		int no;
		
		public Test(){}
		
		public Test (int no){
			//no = no;
			this.no = no; //이 no라는 애가 전역변수 no라는애인걸 밝혀줄때
			
		
		}	함수안에 있는 변수는 접근할수 없다. (실행시키고 블럭빠져나가면 없어지는 변수!!!!!!!!!!!!)함수 내부에서는 접근할수는 있는데, 
			밖에서 쓸라면 전역으로 뽑아놓는게 좋다.
		
	
	}
----------------------------------------------------------------------------------------------------------------------------------


static 속성

	==> static 영역에 생기는 함수, 변수를 말합니다.
	
	참고 ]
	
		클래스, 함수 , 변수를 만들 때 속성을 저장할 수 있다.
		
		예]
			클래스
			
				[접근지정자]	[속성] class  클래스이름{}
				
			함수
				[접근지정자]	[속성] 반환값타입 함수이름(매개변수리스트){}
				
			
			변수
				[접근지정자] 	[속성] 데이터타입 변수이름;
				
		static 영역의 특징 ]
			1. 프로그램이 실행되기 위해서 JVM이 로딩되는 순간 저절로 생기는 영역
				즉, 사용자가 특별히 만들어 달라고 요구하지 않아도 자동적으로 생긴다.
			***		
			2.	 한번 생긴 변수나 함수는 두번다시 생기지 않는다.
				왜? 이름이 중복될꺼니까
				
	static 변수
		==> static 영역에 만들어지는 변수이다.
		
			형식 ]
				static 데이터타입 변수이름;
				
				
			특징 ]
				1. 여러 Object가 공동으로 사용하는 변수가 된다.
				보통 final 과 같이 쓴다.	
				
					class Test{
						static int num = 10;
						int no = 100;
					} 
			
			
			왜?
			오브젝트를 여러개 만들어도
			static 변수는 오직 한개만 존재하므로,,
			
			오브젝트가 데이터를 바꾸면
			다른 오브젝트도 바뀐 데이터를 사용해야 한다.
			
			따라서 결국 소속된 변수(변수.blabla) 의 의미가 없어진다. 공통으로 사용하는거기때문에
			결국 static 변수는 object(주소)의 의미가 없다.
			더군다나 오브젝트가 없어도 사용할 수 있다.클래스이름.변수이름
			
		2.	new 시키지 않아도 사용할 수 있는 변수이다.
			왜? 이미 메모리에 올려져 있으므로..
			
			결론, 
				사용 방법 ]
					클래스 이름.변수이름;
					
					예]
						Math.PI;
						
						
-----------------------------------------------------------------------------------------------------------

static 함수
	==> 역시 변수와 마찬가지로 static영역에 생기는 함수 
		따라서 오브젝트가 없어도 사용할 수 있다.
		
		사용법
		
			클래스이름.함수이름();
			
			
		*특징
		
		=> this.를 사용할 수 없는 함수
		
		**
		결론적으로 ]
		
			static 함수 안에서는 static 멤버만 사용할 수 있다.( Test t = new Test();)
			(반은 맞고 반은 틀리다. ?!)
			
			일반함수 안에서는 일반 멤버와 static 멤버도 사용 할 수 있다.
			
			
			
		HashSet set = new HashSet();
		
		set.add("abcd");
		set.add("bcd");
		set.add("cd");
		set.add("adbc");
		set.add("abcd");
		
		Iterator<E> itor = set.iterator();
		int i = 0;
		while(itor.hasNext())
		
			
			
			
			
-----------------------------------------------------------------------------------------------------------

멤버 변수의 초기화(초기값 세팅)

==> 멤버 변수는 Heap 영역에 생기므로 자동 초기화가 된다.
	하지만 가끔은 변수에 기복적인 값을 지정할 필요가 있다.
	
	1. 명시적 초기화
		==> 변수를 선언 하면서 값을 입력하는 것.
			가장 먼저 실행되는 방법. 
			
			예 ]
			
				class Test{
					int num = 100; // 명시적 초기화
				}	
				
				
	2. 초기화 블럭을 이용한 초기화
		==> 이것은 인스턴스 변수에 대해서만 가능한 것으로 두번째 실행되는 방법
			변수 선언..
			{
				이 안에 데이터를 변수에 입력
			}
			
			예 ] 
				class Test{
				 	int num; 
				 	...
				 	
				 	{
				 		num = 100; 초기화 블럭을 이용한 초기화
				 	}
				}
	3. static 블럭을 이용한 초기화
		==> 2번과 다르게 static 변수에 한해서만 가능한 방법
			두번째 실행되는 방법
			
			형식	]
				static 변수 선언;
				
				static {
					변수에 데이터 대입;
				}
				
				
			예 ]
			
				class Test{
					static int no;
					....
					
					static {
						no = 100;  	//static 블럭을 이용한 초기화
					}
				}
	4. 생성자 함수를 이용한 초기화
		==> 가장 마지막에 실행되는 방법
			예 ]
			
				class Test {
					int no ;
					
					public Test(){}
					
					public Test(int no){
					this.no = no; 	// 생성자 함수를 이용한 초기화
				}

-----------------------------------------------------------------------------------------------------------

객체 지향 언어의 특징

	1. 상속
	2. 다형성
	3. 은닉화 / 캡슐화

-----------------------------------------------------------------------------------------------------------

상속

==> 이미 만들어진 클래스의 기능을 그대로 부여 받아서 
	(멤버(변수,함수)를 그대로 복사 받아서 
	새로운 ㅋ르래스를 만드는 방법
		
	이 개념은
	소프트웨어의개발 속도를 빠르게 하기 위한 방법의 한가지이다.
	
	즉, 상속은 객체지향에서 매우 중요한 역할을 하는 것으로..
	
	객체지향 언어는 부품단위 ( 클래스)로 프로그램을 만든후
	그 부품을 조립해서 원하는 결과를 얻어내는 것이다.
	
	그런데..
	
	어디서 부품(클래스)을 구해왔는데
	그 기능이 사용자 마음에 꼭 맞지는 않을 수 있다.
	그러면 처음부터 다시 만들어야 하는가!?  라는 문제에 도달한다.
	
	이 문제를 해결하기 위해서 만든 방법이 
				'상속' 이다.
				
	상속은 자신이 만들고자 하는 부품과 가장 유사한 부품을 가지고 와서
	일단 그 기능을 복사 한 후에 ...
	
		1.	없는 기능은 덧붙이고,
		2.	있는 기능중에서 바꿀내용은 바꾼다.
		
		
		상속을 하는 형식 ]
			[접근지정자] [속성] class 클래스이름 extends 복사할 클래스 이름{
				복사할 클래스가 가진 모든 기능이 이 안에 안보이더라도
				들어가 있다.
			}
			
	참고 ]
		자바는 오직 단일 상속만 가능하다.
		즉, 상속은 오직 한개의 클래스만 받을 수 있다.
		
		예	]
		
			class Newclass extends OldClss1, Oldclass2 {
			 -----------XXXX 안됨.
			}
		==>
			class NewClass extends OldClass{
			
			}
			
			
용어 정리 ]

	상속을 해준 클래스 - super Class, 상위클래스(부모클래스)
	상속 받은 클래스 - sub Class , 하위 클래스(자식클래스)
	
	is a - 상속관계에 있는 클래스를 부르는 용어
	
		예 ]
		
			class Father{
			}
			class son extends Father{
			}
			
			son is a father 가 성립된다.
			
	has a  - 어떤 클래스 내에 다른 클래스를 멤버로 가지고 있는 상태
	
		예 ]
		
			class Father{}
			
			class son {
				Father t = new Father();
			}
			
----------------------------------------------------------------------------------------
			
			상속관계에 있는 경우 생성자의 역할
			
			결론 ]
				하위 클래스가 생성되는 순간
				상위 클래스가 자동 생성된다.
				==> 생성되는 순간 생성자 함수가 호출
					결국
						하위 클래스를 생성하면
						상위 클래스의 생성자 함수도 실행된다.
						
						
					결국 상위 클래스의 생성자 함수는 자동으로 호출되는 개념이다.
					자동 호출되는 경우에는 무조건 기본 생성자만 이용하게 된다.
					
					
		***
		참고 ] 
		
			super()
			상위 클래스의 특별한 생성자를 강제로 호출하는 기능을 가진 명령이다.
			
			특징 ]
				1. 반드시 생성자 함수의 내에서만 사용 해야 한다.
				2. 반드시 첫줄 첫문장으로 사용해야 한다.
				
				
----------------------------------------------------------------------------------------



*****
함수의 오버라이딩 (Overriding : 함수의 재정의)
==> 상속 관계에 있는 하위 클래스에서
	상위 클래스가 가진 함수의 기능을 수정하는 행위
	
	방법	]	자바에서 만들어지는 모든 클래스들은 object클래스들을 상속받아 만들어진다
				우리가 클래스를 만들게되면 묵시적으로 object 클래스를 상속받게된다.
				
			0. 상속을 받아야 한다.
			1. 상위 클래스가 가진 함수의 원형과 동일한 원형으로 만들어야 한다.
				참고 ]
					함수의 원형(ProtoType)
						반환값	+	함수이름+ 매개변수리스트
						
						
			2. 접근지정자는 같거나 넓은 방향으로..
			
			3. 예외처리는 같거나 좁은 방향으로..
			
			
		이렇게 오버라이딩을 하면
		내부적으로 super(상위클래스)의 함수가 숨겨지고 재 정의한 함수가 사용이된다.
		
		예	]
			
			Class Father{
				void abc(int a){}
			}
			
			Class Son extends Father{
				void abc(int a){
					// 이곳에서 코딩의 내용을 다르게 하면 된다.
				}
			}
			
super

==> this가 실행중인 자신의주소를 기억하는 예약된 변수이듯,
	super도 역시 예약된 변수중 하나이다.
	자신의 상위 클래스의 주소가 기억된 변수이다.
	
	사용목적	]
	
		반드시 상위 클래스임을 밝혀야 하는 경우가 생길때 사용한다.
		
		
----------------------------------------------------------------------------------------

		
# day22

Set 계열
	입력한 순서대로 보관하고 있을 보장이 없다.
	(나름의 규칙에 따라서 내부적으로 정렬해서 보관한다.)
	중복된 데이터는 한번만 저장한다.
	(	같은 데이터가 저장되면
		먼저 데이터를 지우고,
		새로운 데이터로 입력한다. )
		
	1. HashSet
		==> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
			따라서 우리가 생각하는 정렬이 이루어지지 않는다.
			
			#아래는 몰라도 됩니다..
			------------------------------------------------------------
			Hashset(int initialCapacity(초기방수) ,  float LoadFactor)
			
				loadFactor는 해쉬코드값을 만드는 규칙에 사용할 상속값을
				사용자가 지정하면서 해쉬테이블을 만들어서 사용한다.
			------------------------------------------------------------
				
				
		참고 ]
			Set 계열은 컬렉션을 꺼내는 기능이 없다.
				==> 이유는 개발자가 데이터가 저장된 장소를 모르기 때문에..
				리스트로 변경하고 꺼내면 되긴된다.
				특정 위치를 지정하면서 데이터를 꺼낼 수 없다.
				
				따라서 
				1. Iterator로 변환해서 순서대로 꺼내서 사용하도록 하고 있다.
				2. List 계열의 객체를 만들때 Set 데이터를 넣어서 만들어서 꺼내면 된다.
				
---------------------------------------------------------------------------------------------------------------

	TreeSet
	==> 내부적으로 Tree Sort라는 알고리즘을 이용해서
		데이터를 보관하는 기능을 가진 컬렉션의 일종
		
		특징 ]
			우리가 상상하는 정렬방식을 이용한다.
			
		생성방법	]
			
			TreeSet(Comparator comparator)
			==> 정렬방식을 변경해서 TreeSet을 만든다.
			
			TreeSet(SortedSet<E> s)
			==> TreeSet을 이용해서 다시 TreeSet을 만든다.
			
		참고함수 ]
			
			subSet(E fromElement, E toElement)
			==>  하나의 Set에 담긴 내용중에서 특정 부분만 골라서 새로운 Set을 만들어 준다. 
			
			headSet(E toElement)
			==> 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
			
			tailSet(E from Element)
			==> 지정한 부분부터 매 마지막 까지 골라서 새로운 Set을 만든다
			
---------------------------------------------------------------------------------------------------------------

Map 계열
	==> 하나의 데이터를 그 데이터를 구분할 수 있는 키값과
		한 쌍으로 만들어서 데이터를 기억하는 컬렉션의 일종.
		따라서 사용할 경우에는 키값을 이용해서 데이터를 꺼낼 수 있도록 해놓았다.
		
		Map 계열은 많은 양의 데이터를 보관하는 용도 보다는,
		데이터를 손쉽게 구분하여 사용할 목적으로 사용된다.
		
	HashMap / Hashtable 이 있다.
		Hashtable이 구 버전이고, 신 버전이 HashMap이다.
		따라서 HashMap 사용을 권장하고 있다.
		
		내부적으로 키값을 해쉬테이블을 이용해서 정렬해서 보관한다.
		
		주요 함수 ] 
			put(Object key, Object Value);
			==> 데이터를 입력하는 함수
			get(Object key)
			==> 데이터를 꺼내는 함수
			
			참고함수 ]
				values()
				==> 데이터만 꺼내주는 함수.
				
				keys() -- Hashtable 소속의 함수 ( & KeySet()도 있다)
				==> Key값만 뽑아주는 함수.
					참고 ]
						이 함수는 반환값 타입이 Enumeration 으로 반환해준다.
						이 클래스는 Iterator의 구버전이다.
						따라서 이 클래스 역시 데이터를 순차적으로 꺼낼 수 있는 함수
				
				keySet() -- HashMap 소속 함수
				
				
				entrySet()
				==> Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
					(지금까지 배운 함수를 이용하며 꺼낼 수 있는 방법이 있긴 합니다...keys라던가)
					==> 키값과 데이터를 Set으로 묶어주는 함수
					
					그런데,
					Map은 항상 두개가 있어야 저장이 된다. Key, Value;
					Set은 한개만 있으면 저장이 된다.
					따라서 어떻게 해서든지, 두개의 데이터를 하나의 데이터로 만들어야 하는데
					그래서 생겨난 클래스가 Map.Entry 라는 클래스이다.
					Map.Entry 클래스는 
					클래스내부에 Key와 Value라는 변수를 만들어 놓고
					이 변수들을 은닉화 시켜놓았다.
					따라서 두 변수에 접근할 때는 함수를 통해서 접근해야 한다.
				
				
---------------------------------------------------------------------------------------------------------------

	TreeMap
	
	==> TreeSet과 마찬가지로 내부에서 정렬하면서 데이터를 기억하는 Map
		이때 정렬 기준은 키값을 이용해서 정렬하게 된다.
		따라서 키값이 정렬이 되지 않으면 데이터가 입력이 되지 않는다.
		그리고 필요하다면 정렬방식을 정해서 사용할 수 도 있다.
		
	참고 ]
	 	Map에 데이터를 입력할 때 value는 중복되어도 상관이 없지만,
	 	Key는 중복되면 전에 입력한 데이터를 나중에 입력한 데이터로 수정하게 된다.
	 	
	참고 ]
		컬렉션 안에는 다시 컬렉션이 입력될 수 있다..?
		이유는 컬렉션에 입력할 수 있는 데이터는 Object 타입이고
		컬렉션도 클래스 이므로 Object 상속 받은 클래스이다.
		따라서 컬렉션을 입력하는 순간
		Object 타입으로 자동 형변환이 되어서 기억이 된다.
		
---------------------------------------------------------------------------------------------------------------
		
참고 ]
	클래스중 기능이 구현되어 있기 보다는
	변수들로만 구성된 클래스가 있는데 ,
	그런 클래스들을 여러데이터들을 하나의 타입으로 만들어 놓은 (묶어놓은) 클래스이다.
	이런 클래스를 데이터 빈 클래스락도 하고, Value Object 라고 부르고 약자로 VO, 
	또는 DTO (데이터를 묶어서 전송할 목적으로 만들어진 클래스 Data TransForm Object )라고 부른다.




































				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
			
			
			
			
			
			
			
			

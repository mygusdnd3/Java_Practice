# Day18

사용자 예외 클래스 만들기

==> 예외의 클래스는 예외의 발생 원인을 알려주는 역할을 담당한다.
	그런데 예외의 원인이 자바가 알고 있지 않은 클래스라면
	파악을 할 수 없다.
																												
	이런 경우 사용자가 예외 정보를 만들어주는 클래스를 따로 만들어서 사용할 수 있다.
	
	방법	]
	
		1. 모든 예외의 최상의 클래스 
			Exception 클래스를 상속을 받은 클래스를 제작한다.]
		
		2. toString()을 오버라이드 하여
			예외의 원인을 출력 할수 있도록 한다.
			 getClass().getName() + '@' + Integer.toHexString(hashCode())
 
 
 -----------------------------------------------------------------------------------------
 
 강제 예외 던지기 (강제 예외 발생) 
 ==> JVM은 예외로 인정하지 않는데,
 	(==> 원칙상 예외 처리가 필요하지 않지만..)
 	프로그램의 목적상 예외로 인정해야 하는 경우가 있을 수 있다.
 	
 	예	]
 		1 ~ 10 사이의 숫자만 입력 받고싶다.
 		음수는 입력 받고 싶지않다.
 		
 		이런경우는 사용자가 이것은 문제가 있다고
 		JVM 에게 강제로 알려주는 방법이다. 
 		
 		
 	형식 ]
 		
 		throw new 예외클래스 이름
 		
 		
 	주의 ]
 	
 		예외 전이
 			==> 함수에 사용하느 기법
 				형식 ]
 					throws 예외 클래스 이름
 		예외 던지기 
 			==> 명령문
 			
 				형식 ]
 					throw new 예외클래스 이름(); //throw 예외클래스 인스턴스;
 -----------------------------------------------------------------------------------------
 예외 전이하기
 
 ==> 함수는 프로그램의 가장 작은 단위로
 	 한가지 작업을 하기 위해서 만든 것이다.
 	 따라서 함수 안에서 작업을 하다가 예외가 발생하면
 	 그 함수는 더이상 실행할 필요가 없는 경우가 많다.
 	 따라서 함수는 예외를 전이하도록 해 놓은 경우가 있다. 
 	 (  
 	 	==> 예외가 발생하면 그 명려에서 예외처리를 해 주어야 하는데,
 	 		그 명령에서 하지 않고 
 	 		함수를 호출한 곳으로 예외 처리를 떠넘기는 경우가 있는데
 	 		이것을 예외 전이라 한다. 호출한곳에다 니가좀 예외처리해달라고
 	 		
 	 )
 	 
 형식	]
 	 	
 	 [접근지정자] [속성] 반환값타입 함수이름(매개변수 리스트) throws 예외 클래스1,예외클ㄹ스2...{
 	 	}
 	 	
 의미	]
 
 	>>이 함수는 throws 한 예외가 발생할 수 있다.<<
 	
 	지정한 예외가 발생하면 이 함수는 더이상 실행해도 의미가 없으므로
 	실행을 중지시킨다.
 	
 	****
 	예외가 전이된 함수는
 	그 함수를 호출한(사용하는) 곳에서 반드시 예외 처리를 해줘야 한다.
 	
 	참고 ] 
 		==> 비록 어떤 함수가 예외를 전이하는 함수라도
 			예외처리를 하지 않아도 되는 경우가 있다.
 			
 			예외가 RuntimeException의 하위 클래스인 경우에는
 			예외처리를 해도그만, 안해도 그만이다.
 			(주로 java.lang 소속의 클래스에 있는 함수들이 이런 것들이 많이 존재한다.)
 			
 			하지만, 될수있으면 해주는 것이 좋다.
 			
 	함수의 오버라이딩 규칙 ]
 	
 		0.	상속을 받아야 한다.
 		1.	함수의 원형을 유지한다.
 		2.	접근지정자는 같거나 넓거나.
 		3.	예외 처리는 같거나 좁은 방향으로 (같거나 하위의 예외를 전이할 것)
 -----------------------------------------------------------------------------------------
 
 Object 클래스
 ==> 자바로 만든 클래스의 최상위 클래스 역할을 하는 클래스
 	 하는 일은 졀로 없고
 	 자바 상속 관계를 명확하게 하기 위한 역할을 위한 클래스
 	 
 	 1. toString()
 	 	==> 객체의 주소를 반환해 주는 함수
 	 		==> 하위 클래스에서 오버라이딩(재정의)를 해서 다른 내용이 출력되도록 사용한다.
 	 		
 	 2. equals()
 	 	==> 비교함수
 	 		Object가 가지고 있는 내용을 비교하는 함수가 아니고
 	 		***
 	 		주소를 비교하는 함수이다.
 	 		
 	 		참고 ] 
 	 			우리가 String 클래스의 equals() 함수를 사용해서 데이터의 내용을 비교하는데
 	 			사용 했는데,
 	 			이것은, String클래스가 Object의 이 함수를 오버라이드 하여 
 	 			기능을 데이터내용 비교로 변경해 놓았기 때문이다.
 	 		참고 ]
 	 			만약 우리가 만든 클래스도 내용 비교를 하도록 원하면
 	 			이 함수를 오버라이드 하여 기능을 수정하면 된다.
 	 			
 -----------------------------------------------------------------------------------------
 
 참고 ]
 	오버라이드 규칙 ]
 		0. 상속을 받아야 한다.
 		1. 함수의 원형을 유지한다. (함수의 원형 : 반환값타입 + 함수이름 + 매개변수리스트)
 		2. 접근지정자는 같거나 넓은 방향으로..
 		3. 예외처리는 같거나 좁은 방향으로
 			예외를 전이하는 함수는 
 			== throws 하는 예외는 같거나 줄어들 수 있다.
 			하지만 상위 클래스에서 던지지 않은 예외를 던지면 절대로 안된다. 
 			
 	
 	예 ]
 	
 		void abc(int a, int b) throws InvalidNumberException, NotANumberException{}
 		
 		이것을 오버라이드 할 때
 		void abc(int a, int b) throws InvalidNumberException, NotANumberException{}
 		---------O
 		
 		void abc(int a, int b) throws InvalidNumberException{} -----------O
 		
 		void abc(int a, int b) throws Exception{} -----------X
 		예외의 범위가 넓어진 상태로 안된다.
 		
 		void abc(int a, int b) throws EOFException{} -----------X
 		전이하지 않는 예외를 추가 하는 것도 안된다.
 		
 		
 -----------------------------------------------------------------------------------------
 
 StringBuffer
 ==> String과 동일하게 문자열을 관리하는 클래스
 	***
 		차이점
 			String 은 내용이 변화되면 새로운 메모리를 다시 확보하고 
 			변화된 내용은 다시 기억한 후 주소를 바꾼다.
 			
 			StringBuffer는 String의 문제점을 해결하기 위해서 만들어 놓은
 			또 하나의 문자열 관리 클래스로
 			내용의 변화가 있으면, 현재 메모리에 변화된 내용을 그대로 기억한다. 
 			
 			
 		참고 ]
 			String str = "Hong"; 	==> String 은 너무 자주 사용되는 클래스이므로
 										유일하게 자바가 클래스 타입에 허용하는 문법이다.;
			StringBuffer는 String과 달리 대입연산자 '='로 문자열 기억이 불가능하다.
			반드시 객체지향 원리에 따라서 
			반드시 new 시켜서 사용해야 한다. 
			
			StringBuffer buff = "Hong"; -------------------------X
			StringBuffer buff = new StringBuffer("Hong");--------O
		
		참고 ]
		
			String str = "Hong";
			str = str+" gildong";
			즉, + (결합연산자)를 사용해서 문자열을 결합하는 것 역시
			오직 String 클래스에 한해서만 허용되는 문법이다. 
			
			나머지 클래스는 반드시 그 클래스가 가진 기능(함수)를 이용해서
			필요한 처리를 해 줘야 한다. 
			
			StringBuffer buff = new StringBuffer("Hong");
			buffappend(" gildong");
			
		참고 ] 
			
			실무에서 StringBuffer 활용 방법
			
			1. String이 편하므로 String으로 먼저 만들어둔다.
			
				String str = "Hong";
			
			2. 문자열이 변화가 일어나는 시점이 되면
				그 순간에 StringBuffer로 변환시킨다.
				StringBuffer buff = new StringBuffer(str);
				
			3. StringBuffer 를 이용해서 문자열을 변하 시킨다.
				==> 메모리가 낭비되는 현상이 없어진다.
				
			4. 문자열의 변화가 종료되면 다시 자주 사용되는 String 타입으로 변환시켜서 사용한다.
			
				str = buff.toString();
				str = new String(buff);
				
		
	참고 ]
		StringBuilder
		=> 이 클래스 역시 StringBuffer와 동일한 역할을 하는 클래스
			주로 Thread 처리를 할 때 동기화에 대해서 안정적으로 처리가 가능하다.
			
 			
-----------------------------------------------------------------------------------------

Math 클래스
==> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스
	모든 멤버가 static 이므로 굳이 new 시키지 않아도 사용할 수 있는 클래스이며
	아예 new 시키지 못하도록 조치해 놓은 클래스이다.
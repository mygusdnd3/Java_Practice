#day 16

내부 클래스
==> 클래스 내부에 다시 클래스를 만들 수 있다.


종류
	1. Top Level Inner Class
		=> 비록 형식은 내부 클래스이지만 독립적으로 활동하는 클래스
		
		형식	]
			
			static class 클래스 이름{}
			
			
		다시 말해서 클래스 내부에 만드면서 static이 붙으면 Top Level Class가 된다.
		
		참고 ]
		
			클래스 이름
			
			일반 클래스와는 다르게 내부 클래스의 이름은 
			"바깥클래스이름.내부클래스이름" 형식을 취한다.
			
	***
	2. 전역 Inner Class
		==> 일반 클래스를 내부 클래스로 만든 것.
			(이 클래스가 우리가 내부 클래스라는 것의 90%정도 차지한다)
			
		형식 ]
			
			class 클래스이름{
			}
			
		특징 ]
			1. 바깥 클래스의 모든 멤버는 
				자기것처럼 사용할 수 있다.
				
				
				====>
				
						public class T01{
							int no;
							void abc(){}  << 요기서도 no를 내꺼처럼 쓸수있다. 전역변수
							
							class T01_01{
							 no = 100 <<  요기서도 마찬가지  
							 abc();
							}
						}
						
			2. 반드시 바깥 클래스가 객체가 되어야 (new) 안쪽 클래스를 생성 할 수 있다.
			
				형식	]
					바깥클래스주소.new 안쪽 클래스이름();
					
						예	]
							T01 t = new T01();
							T01_01 t1 = t.new T01_01();

							
							new T01().newT01_01();
							
							
			3. 바깥 클래스는 안쪽 클래스 멤버를 사용할 수 없고
				사용하기 위해서는 new 시켜서 사용해야 한다.
				
			주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을 때
			주로 사용하는 기법
			
			
	3. 지역 Inner Class
		==> 내부 클래스를 만드는 위치가 바깥 클래스의 함수 내부에서? 만드는 경우
			그 클래스를 지역 내부 클래스라 부른다.
			
			class Test{
				int a;
				class Inner01{---->전역 내부클래스
				
				}
				
				void abc(){
					int b;		   -- 지역 변수
					class Inner02{ -- 지역 내부클래스
					
					}
					
				}
			}
			
			참고]
				int no = Integer.ParseInt(sc.Nextline());
				의 경우 매개변수에 함수 자체를 입력하는 것이 아니고
				함수 실행의 결과값을 리턴해주는것.
				
				
				
			특징 ] 
				1. 전역 내부 클래스와 유사하게 바깥 클래스의 멤버를 모두 사용할 수 있다.
				2. 이 클래스는 다른 곳에서 new 시킬 수 없다. 
					오직 해당 함수 내 에서만 new 시킬 수 있다.
					
					
	4. 무명 Inner class 
		==> 이름이 없는 내부 클래스를 말한다.
		
			프로그램을 만들다보면
			클래스의 기능 수정을 위해서 오버라이드를 해야하는 경우가 발생한다.
			(또는 어쩔수 없이 오버라이드를 해야하는 경우도 있다.추상클래스, 인터페이스의 경우는 추상함수를 반드시 오버라이드 해야한다.)
			
			이때 간단한 오버라이드를 해야하는 경우
			그 기능 하나때문에 클래스를 따로 만들어야 하는 불편함이 있다. 
			
			예를들어 프로그램을 강제로 종ㄹ하는 명령은
				system.exit(0);
				인데 
			이 한줄을 쓰기위해서 클래스를 다시 만들어야 한다.
			결론적으로
			
			무명클래스란?
			바로 이런 경우를 위해서 만들어진 클래스로 
			클래스를 new 시키는 순간 필요한 기능을 오버라이드 해서  사용하는 방법
			즉, 사용자가 클래스 이름을 만들지 않아도 된다.. 라는 의미에서 무명이라고 부른다
			
			형식	 [
				new 상속받을 클래스이름(){
					함수 오버라이드..
				}
				
public class Test05 {

		public Test05() {
					xyz(new Ifc() {	<--xyz 함수 호출 인터페이스를 바로 new시킴
						public void abc() {	<--인터페이스 오버라이딩
						System.out.println("무명의 클래스 호출");
							}
						});
					}
					
	public static void main(String[] args) {
	new Test05();
	}
	public void xyz(Ifc i) {  <-- 인터페이스형 i를 받아서 
		i.abc();  <----인터페이스 내부 함수호출
	}

}

interface Ifc {
	void abc();
}


------------------------------------------------------------------------------------------------------------------------------------

예외처리

==> 프로그램적으로는 문제가 없으나 (문법상 전혀 에러가 나지 않으나)
	데이터의 문제나 장비의 문제 등에 의해서 프로그램을 실행하는 도중 발생하는
	에러를 "실행에러 (Runtime Error)" 라고 표현하고
	이것을 자바에서는 "예외(Exception)" 이라고 표현한다.
	
	문제는
	이런 예외는 개발자가 예측해서 이런 문제가 발생했을 경우 대처하는 방식으로 프로그램을 제작해야한다.
	이렇게 예외가 발생했을 경우대처하는 방식의 프로그램을
			 "예외 처리" 
	라고 표현한다.
	
	자바에서는 이런 문제점(예외 발생 원인을 개발자가 알고 있어야 한다.)을 해결하기 위해서
	예외처리 문법이 존재한다.
	
	
	형식 ]
	
	
		--------------------------------1 )
		try{
			----------------------------2)		
			실행문----------------------3)
			----------------------------4)
			} catch( ???? 변수이름){			///???? -----> 예외 클래스 이름
			----------------------------5)
			} finally{
			----------------------------6)
			}
			----------------------------7)
			
			3) 은 예외가 발생할 위험 요소가 존재하는 부분
			5) 예외 발생시 문제점을 해결하는 부분
			6) 예외 발생 여부와 관계없이 실행되는 부분
			
				실행 순서 ]
					1) -> 2) -> 3) - 예외발생			------>5)-->6) --->7)
								     예외발생 안한경우	------>4)-->6^ ---->7) 
								     
				
				문제점
					4) 이 문제인데
						이 부분에 있는 부분은 예외가 발생하면 실행되지 않고
					====> 따라서 try{} 의 범위에 따라서 실행 할 수 있고 (3번하다 에러나면 바로 내려감)
														실행 되지 않을 수도 있다.
	
	
	
						예	]
							String str = JOptionPane.showInputDialog("정수를 입력하세요");
							
							int no = Integer.paseInt(str); //------이 부분은 숫자 정수 형식의 문자열이 아닌경우는
							 										예외가 발생하게 된다.
							 										따라서 예외처리가 필요하다.
							 										
							 										
							int no = 0;
							try{
							
								no = Integer.paseInt(str);
							
							} catch (Exception e){
								no = -999;
							}
							
							
							System.out.println(no)
							
							
			자바의 예외처리 원리
			
				예외가 발생하면 JVM은 발생한 예외의 종류를 분석한 후
				예외에 대한 정보를 클래스로 만들어서
				catch부분에 그 클래스의 주소를 전달한다.
				
				
				
		catch 의 의미
		
			==> 예외가 발생하면 그 예외의 정보를 받아서
				개발자가 그 정보를 이용해서 원하는 처리를 해 주어야 한다.
				
		다중 catch
		
			==> try{} 안에 예외 발생 요소가 여러가지 복합적인 예외 발생 요소를 가질수 있다.
			
				이때 반드시 어떤 에러때문인지를 구분해줘야 한다면???
				이런 경우를 대비해서 만들어 놓은 방법이
					다중 catch
				이다 .
				
				형식]
				
					try{
					} catch(???){
					} catch(???){
					} catch(???){
					.....
					}
					**
					문제는
						다중 catch를 사용하는 경우 
						반드시 실행될 수 있는 상태로 만들어야 한다.
						==> 좁은 범위으 catch가 먼저 와야한다 반드시.
						
						
						
						
	finally 블럭
	==> 예외 발생 여부와 관계없이 반드시 실행 되어야 할
		문장이 존재 할 경우 이런 문장을 입력하는 블럭을 말한다.
		
		참고	]
			만약 finally 존재하면 catch를 생략할 수도 있다.
			
		
	예외 정보 출력하기
	==>
		1. 예외 클래스 변수를 출력하면 된다.
			예	]
			 	System.out.println(예외클래스 변수)
				==> 예외의 원인을 파악할 수 있게 된다.
				
				
		2. 변수.printStackTrace() 를 이용하는 방법
			==> 예외의 정보 + 예외가 발생하게된 위치와
							  그 경로를 추적해서 출력해준다.	
				
				
	예외가 발생하면 개발자가 그것을 수정해서 정상적으로
	동작하도록 만드는 행위가 예외처리이다
	==> 프로그램의 정.상.적.인  종료
	(예외처리를 하지않으면 문제가 발생한 그 라인에서 멈춰버린다)
	하지만 정상적으로 동작하도록 만드는 행위는
	매우 어려운 일이며, 그 경우가 많지 않다.
	
	다만 예외 처리를 하는 실제 이유는
	예외의정보를 알아서 사용자에게 왜 프로그램에
	문제가 생겼는지 알려주고, 그 프로그램을 정상적으로 종료하도록 
	하는 것에 목적이 있는 경우가 많다.
	
				
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
					
	
	
		
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	